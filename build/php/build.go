// build/php/build.go - PHP Build Configuration Generator
// Run: go run build/php/build.go --version 8.3 --output /tmp/configure.sh
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// Extension definition from extensions.yaml
type Extension struct {
	Name   string   `yaml:"name"`
	Static bool     `yaml:"static"`
	Deps   []string `yaml:"deps"`
}

// VersionConfig from extensions.yaml
type VersionConfig struct {
	ConfigureFlags []string `yaml:"configure_flags"`
}

// ExtensionsConfig represents the full extensions.yaml structure
type ExtensionsConfig struct {
	Versions           map[string]VersionConfig `yaml:"versions"`
	CoreExtensions     []Extension              `yaml:"core_extensions"`
	OptionalExtensions []Extension              `yaml:"optional_extensions"`
	SystemDeps         []string                 `yaml:"system_deps"`
}

func main() {
	version := flag.String("version", "8.3", "PHP version to build (7.4, 8.0, 8.1, 8.2, 8.3, 8.4)")
	output := flag.String("output", "", "Output file for configure script (default: stdout)")
	extensions := flag.String("extensions", "", "Comma-separated list of optional extensions to include")
	configPath := flag.String("config", filepath.Join("build", "php", "extensions.yaml"), "Path to extensions.yaml (default: build/php/extensions.yaml from current working directory)")
	flag.Parse()

	// Read extensions.yaml
	data, err := os.ReadFile(*configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading extensions.yaml at %s: %v\n", *configPath, err)
		os.Exit(1)
	}

	var config ExtensionsConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing extensions.yaml: %v\n", err)
		os.Exit(1)
	}

	// Validate version
	if _, ok := config.Versions[*version]; !ok {
		fmt.Fprintf(os.Stderr, "Invalid PHP version: %s\nValid versions: ", *version)
		for v := range config.Versions {
			fmt.Fprintf(os.Stderr, "%s ", v)
		}
		fmt.Fprintln(os.Stderr)
		os.Exit(1)
	}

	// Parse requested optional extensions
	requestedOptional := make(map[string]bool)
	if *extensions != "" {
		for _, ext := range strings.Split(*extensions, ",") {
			requestedOptional[strings.TrimSpace(ext)] = true
		}
	}

	// Build configure arguments
	var args []string

	// Version-specific flags
	args = append(args, config.Versions[*version].ConfigureFlags...)

	// Core extensions (always static)
	for _, ext := range config.CoreExtensions {
		args = append(args, fmt.Sprintf("--enable-%s", ext.Name))
	}

	// Optional extensions (shared if requested, skip otherwise)
	for _, ext := range config.OptionalExtensions {
		if requestedOptional[ext.Name] {
			args = append(args, fmt.Sprintf("--enable-%s=shared", ext.Name))
		}
	}

	// Build configure command
	configureCmd := "./configure " + strings.Join(args, " \\\n    ")

	// Generate build script
	script := fmt.Sprintf(`#!/bin/sh
# PHP %s Build Script for Maboo
# Generated by build/php/build.go

set -e

PHP_VERSION="%s"
BUILD_DIR="/tmp/php-build-$PHP_VERSION"
INSTALL_PREFIX="/usr/local"

echo "Building PHP $PHP_VERSION for Maboo..."

# Install dependencies (Alpine)
apk add --no-cache %s

# Download PHP source
if [ ! -d "$BUILD_DIR" ]; then
    mkdir -p "$BUILD_DIR"
    cd "$BUILD_DIR"
    wget -q https://www.php.net/distributions/php-$PHP_VERSION.tar.gz
    tar xzf php-$PHP_VERSION.tar.gz --strip-components=1
    rm php-$PHP_VERSION.tar.gz
fi

cd "$BUILD_DIR"

# Configure
%s

# Build
make -j$(nproc)

# Install
make install

# Create libphp.so (shared library)
if [ ! -f "$INSTALL_PREFIX/lib/libphp.so" ]; then
    # For embedded PHP, we need to build as shared library
    # This requires custom configure options
    echo "Note: libphp.so creation requires custom PHP build configuration"
fi

echo "PHP $PHP_VERSION build complete!"
echo "Installed to: $INSTALL_PREFIX"
`, *version, *version, strings.Join(config.SystemDeps, " "), configureCmd)

	// Output
	if *output != "" {
		if err := os.WriteFile(*output, []byte(script), 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Build script written to: %s\n", *output)
	} else {
		fmt.Println(script)
	}

	// Print summary
	fmt.Fprintf(os.Stderr, "\n=== Build Summary ===\n")
	fmt.Fprintf(os.Stderr, "PHP Version: %s\n", *version)
	fmt.Fprintf(os.Stderr, "Core Extensions: %d\n", len(config.CoreExtensions))
	fmt.Fprintf(os.Stderr, "Optional Extensions Requested: %d\n", len(requestedOptional))
	if len(requestedOptional) > 0 {
		fmt.Fprintf(os.Stderr, "  %s\n", strings.Join(keys(requestedOptional), ", "))
	}
	fmt.Fprintf(os.Stderr, "System Dependencies: %d\n", len(config.SystemDeps))
}

func keys(m map[string]bool) []string {
	k := make([]string, 0, len(m))
	for key := range m {
		k = append(k, key)
	}
	return k
}
